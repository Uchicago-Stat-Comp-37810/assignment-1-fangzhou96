---
title: "Break statements exercise 2"
author: "Fangzhou Yang"
date: "10/05/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question 8
**while statements: section 4.1.5, exercises 2**

# (a).
```{r}
Eratosthenes <- function(n) {
# Print prime numbers up to n (based on the sieve of Eratosthenes)
if (n >= 2) {
 sieve <- seq(2, n)
 primes <- c()
while (length(sieve) > 0) 
  {
 p <- sieve[1]
 primes <- c(primes, p)
 sieve <- sieve[(sieve %% p) != 0]
  }
return(primes)
  } else {
 stop("Input value of n should be at least 2.")
  }
}
```
We'd like to find all prime numbers up to the given value n through this function. Initially, all
integers from 2 through n are stored and the primes object is set up initially empty. The composite numbers in sieve are removed, and the primes are copied to primes. We can use sieve[(sieve %% p) != 0] to eliminate all multiples of p. This step also eliminates p, but we have already saved it in primes.


# (b).
Since the elements remaining are primes, which are not multiples of integers greater than 2 and smaller than itself. And an integer(<n) which is not a multiple of any integer >= 2 and <= sqrt(n) must be a prime. 
Thus, once p >= sqrt(n), all remaining entries in sieve are prime.


# (c).
```{r}
Eratosthenes <- function(n) {
  # Print prime numbers up to n (based on the sieve of Eratosthenes)
if (n >= 2) 
  {
   sieve <- seq(2, n)
   primes <- c()
  repeat
    {
     p <- sieve[1]
     primes <- c(primes, p)
     sieve <- sieve[(sieve %% p) != 0]
     if (length(sieve) <= 0) break
    }
  return(primes)
  } else {
    stop("Input value of n should be at least 2.")
  }
}

```

